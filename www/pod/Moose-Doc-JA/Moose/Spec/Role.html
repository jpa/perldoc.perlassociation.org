<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Japan Perl Association CPAN和訳ドキュメント">
<meta name="keyword" content="perl,cpan,jpa,和訳,日本語訳">
<title>Moose::Spec::Role Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css" />
</head>
<body>
<h1>Moose::Spec::Role</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <strong>Moose::Spec::Role</strong></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">本文</a>
<ul>
<li>
<ul><li><a href="#-3">ロールの構成要素</a></li>
<li><a href="#-4">ロールの組み込み</a>
<ul><li><a href="#-5">クラスに組み込む場合</a></li>
<li><a href="#-6">インスタンスに組み込む場合</a></li>
<li><a href="#-7">ロールに組み込む場合</a></li>
<li><a href="#-8">ロールの合成</a></li>
<li><a href="#-9">特殊な組み込み例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#-10">参照</a></li>
<li><a href="#-11">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Spec::Role - ロールの振る舞いに関する公式仕様</p>

</div>
<h2 id="-2">本文</h2>
<div id="CONTENT-2">
<p><strong>注意:</strong> このドキュメントには現在不備があります。</p>

</div>
<h3 id="-3">ロールの構成要素</h3>
<div id="CONTENT-3">
<dl>
	<dt>排除ロール</dt>
	<dd>
		<p>ロールには排除するロールの一覧が定義されていることがあります。これは基本的に合成できないロールのことです。これは直接合成できないものだけでなく、「継承」したときに合成できないものも含まれます。</p>
		<p>この機能はFortress言語をまねたものですが、大量のロールを「ブロック」のように組み合わせていくときには本当に役に立ちます。「ブロック」の中にはどうしても組み合わせられないものもあるからです。</p>
	</dd>
	<dt>アトリビュート</dt>
	<dd>
		<p>ロールのアトリビュートはクラスのアトリビュートと似ていますが、実際にロールに適用されるわけではないところが異なります。つまり、アトリビュートアクセサが生成するメソッドは、そのロールの中で生成されるのではなく、ロールがなにかのクラスに組み込まれてから作成される、ということです。</p>
	</dd>
	<dt>メソッド</dt>
	<dd>
		<p>ロールの中で定義されるメソッドは次の通りです。簡単ですよね？</p>
	</dd>
	<dt>必須メソッド</dt>
	<dd>
		<p>ロールは、取り込む側のクラス（ないしロール）が特定のメソッドを提供していることを要求することがあります。クラスがそのメソッドを提供していない場合は致命的なエラーになります。組み込み先がロールの場合は、メソッドの要件をそのロールに引き継ぎます（致命的なエラーにはなりません）。</p>
	</dd>
	<dt>必須アトリビュート</dt>
	<dd>
		<p>ロールは、特定のメソッドを必要とすることがあるのと同様に、特定のアトリビュートを必要とすることもあります。この場合、対象となるアトリビュートは、最低でも必要とされる要件を満たしている必要があります。つまり、たとえばあるロールが読み取り専用のアトリビュートを要求している場合、そのアトリビュートは少なくとも読み取り用のアクセサを持っている必要があります（ただし、書き込み用のミューテータを持っていてもかまいません）。ロールが配列リファレンス型のアトリビュートを要求している場合、そのアトリビュートの型は配列リファレンスあるいはそのサブタイプでなければなりません。</p>
	</dd>
	<dt>オーバーライドされるメソッド</dt>
	<dd>
		<p><code>override</code>と<code>super</code>はロールの中でも使えますが、その挙動はクラスの場合とは異なります。クラスの<code>super</code>は直接そのクラスのスーパークラスを指しますが、ロールの<code>super</code>は遅延評価され、クラスに合成されるまで意味を持ちません。合成されてからは、<code>super</code>はそのクラスのスーパークラスを指すようになります。</p>
		<p>ロールは階層構造を持たないということはぜひ覚えておいてください。だからこそ、「スーパー」ロールを持つことはありえないのです。</p>
	</dd>
	<dt>メソッドモディファイア</dt>
	<dd>
		<p>Mooseのクラスが提供している<code>before</code>や<code>around</code>、<code>after</code>といったモディファイアも利用できますが、こちらも実際にロールがクラスに合成されるまでは適用されないという違いがあります（アトリビュートや<code>override</code>の場合と同じです）。</p>
	</dd>
</dl>

</div>
<h3 id="-4">ロールの組み込み</h3>
<div id="CONTENT-4">

</div>
<h4 id="-5">クラスに組み込む場合</h4>
<div id="CONTENT-5">
<dl>
	<dt>排除ロール</dt>
	<dt>必須メソッド</dt>
	<dt>必須アトリビュート</dt>
	<dt>アトリビュート</dt>
	<dt>メソッド</dt>
	<dt>オーバーライドされるメソッド</dt>
	<dt>メソッドモディファイア(before、around、after)</dt>
</dl>

</div>
<h4 id="-6">インスタンスに組み込む場合</h4>
<div id="CONTENT-6">

</div>
<h4 id="-7">ロールに組み込む場合</h4>
<div id="CONTENT-7">
<dl>
	<dt>排除ロール</dt>
	<dt>必須メソッド</dt>
	<dt>必須アトリビュート</dt>
	<dt>アトリビュート</dt>
	<dt>メソッド</dt>
	<dt>オーバーライドされるメソッド</dt>
	<dt>メソッドモディファイア(before、around、after)</dt>
</dl>

</div>
<h4 id="-8">ロールの合成</h4>
<div id="CONTENT-8">
<p>あるロールに（<code>with @roles</code>を利用して）複数のロールを組み込んだ場合は対称差を利用して合成されます。このようにしてできたロールを合成ロールといいます(<cite>Moose::Meta::Role::Composite</cite>)。</p>
<dl>
	<dt>排除ロール</dt>
	<dt>必須メソッド</dt>
	<dt>必須アトリビュート</dt>
	<dt>アトリビュート</dt>
	<dd>
		<p>同じ名前を持つアトリビュートが複数ある場合は衝突を起こして回復不能なエラーとみなされます。アトリビュートのほかの要素は考慮されません。アトリビュート名が衝突しているだけで十分です。</p>
		<p>このようにアトリビュートの衝突判定が非常に早く、厳しいものになっているのは、アトリビュートは変動の幅が大きいのですぐに収拾がつかなくなってしまうためです。また、判定のルールも非常に煩雑なものになってしまいますし、そのような手間をかけるだけの価値はないと筆者は考えています。</p>
	</dd>
	<dt>メソッド</dt>
	<dd>
		<p>同じ名前を持つメソッドが複数ある場合は衝突を起こしますが、エラーにはなりません。そのかわりにそのメソッド名が新しくできた合成ロールの「必須」メソッドのリストに追加されます。</p>
		<p>これを集合論の観点から見ると、それぞれのロールはメソッドの集合を持つことができると言えます。そして、この2つの集合の対称差が新たに合成ロールのメソッドの集合になり、2つの集合の積集合が衝突になります。例を示すと、このようになります。</p>
<pre>   Role A has method set { a, b, c }
   Role B has method set { c, d, e }

   The composite role (A,B) has
       method   set { a, b, d, e }
       conflict set { c }

</pre>
	</dd>
	<dt>オーバーライドされるメソッド</dt>
	<dd>
		<p>オーバーライドされたメソッドが衝突を起こす場合は2通りあります。</p>
		<p>まず、同じ名前を持つ別のオーバーライドされたメソッドがある場合。これは回復不能なエラーとみなされます。これがエラーになるのは自明でしょう。同じクラスの中でひとつのメソッドを2度オーバーライドすることはできません。</p>
		<p>2つめは、オーバーライドされたメソッドと通常のメソッドが同じ名前を持つ場合です。これも回復不能なエラーです。この2つのメソッドを合成する方法はありませんし、両者をどこかでひとつのクラスに合成することもできないからです。</p>
		<p>ロールの中でオーバーライドするのはトリッキーですが、気をつけて使えば非常に強力なツールになることもあります。</p>
	</dd>
	<dt>メソッドモディファイア(before、around、after)</dt>
	<dd>
		<p>メソッドモディファイアだけはロールを合成するときでも順序を気にしなければなりません。これはメソッドモディファイアそのものの性質のためです。</p>
		<p>メソッドは複数のメソッドモディファイアを持つことがあるため、ロールを組み込む段階ではモディファイアは適用されません。クラスに組み込んだときに同じ順番で適用できるよう収集されるだけです。</p>
		<p>一般論として、ロールの中でメソッドモディファイアを使うときは細心の注意を払ってください。このように順序の問題があるため、使いすぎると微妙で見つけづらいバグのもとになることもあります。人生なにごとも節度が肝心です。</p>
	</dd>
</dl>

</div>
<h4 id="-9">特殊な組み込み例</h4>
<div id="CONTENT-9">
<p>ここでは混乱しやすい複雑な特殊をいくつか紹介します。これは問題を明確にして、中でなにが起こっているを説明しようというものです。</p>
<dl>
	<dt>ロールメソッドのオーバーライド</dt>
	<dd>
		<p>取り込もうとしているロールのメソッドを「オーバーライド」したがる人は多いのですが、これは相手がクラスであればうまくいくものの（ローカルなクラスメソッドの方がロールのメソッドより優先されるためです）、ロールが相手の場合はかなりトリッキーなことになります。メソッドの衝突が起こると、どちらのメソッドも組み込まれず、「必須」メソッドになってしまうのです。</p>
		<p>この(正しくない)オーバーライドの例をあげます。</p>
<pre>    package Role::Foo;
    use Moose::Role;

    sub foo { ... }

    package Role::FooBar;
    use Moose::Role;

    with 'Role::Foo';

    sub foo { ... }
    sub bar { ... }

</pre>
		<p>この場合、<code>foo</code>メソッドが衝突を起こしていますので、Role::FooBarは取り込む側のクラスやロールに<code>foo</code>の実装を要求します。これはたいていの場合期待した動作ではないはずです。</p>
		<p>こちらは(正しい)オーバーライドの例です。もっとも、これも次に説明するように、オーバーライドはいっさい起こっていません。</p>
<pre>    package Role::Foo;
    use Moose::Role;

    sub foo { ... }

    package Role::Bar;
    use Moose::Role;

    sub foo { ... }
    sub bar { ... }

    package Role::FooBar;
    use Moose::Role;

    with 'Role::Foo', 'Role::Bar';

    sub foo { ... }

</pre>
		<p>これが動作するのは、Role::FooとRole::Barを合成すると<code>foo</code>が衝突するため、<code>foo</code>が(<i>with</i>を使って合成されたRole::FooとRole::Barの)合成ロールの必須メソッドになり、その要件をRole::FooBarが満たすからです。</p>
		<p>大事なのは、Role::FooBarは単に<code>foo</code>メソッドの要件を満たしているだけで、<code>foo</code>をオーバーライドしている「わけではない」ということ。これは大きな違いになります。</p>
		<p>さらにもうひとつ(正しい)オーバーライドの例を見ましょう。今度は<i>excludes</i>オプションを使います。</p>
<pre>    package Role::Foo;
    use Moose::Role;

    sub foo { ... }

    package Role::FooBar;
    use Moose::Role;

    with 'Role::Foo' =&gt; { excludes =&gt; 'foo' };

    sub foo { ... }
    sub bar { ... }

</pre>
		<p>合成するときに<code>foo</code>メソッドを明示的に排除すると、<strong>Role::FooBar</strong>に自前の<code>foo</code>を定義できるようになります。</p>
	</dd>
</dl>

</div>
<h2 id="-10">参照</h2>
<div id="CONTENT-10">
<dl>
	<dt>トレート(Traits)</dt>
	<dd>
		<p>ロールはSmalltalkコミュニティで生まれたトレートが元になっています。</p>
		<p>
			<dl>
				<dt><a href="http://www.iam.unibe.ch/~scg/Research/Traits/">http://www.iam.unibe.ch/~scg/Research/Traits/</a></dt>
				<dd>
					<p>ここは元になったトレート論文のメインサイトです。</p>
				</dd>
				<dt><cite>Class::Trait</cite></dt>
				<dd>
					<p>私が数年前に上でリンクした論文を読んでトレートを実装したものです（このモジュールは現在Ovidがメンテナンスしています。私はもう関与していません）。</p>
				</dd>
			</dl>
		</p>
	</dd>
	<dt>ロール</dt>
	<dd>
		<p>ロールという概念は比較的新しいものですし、おそらくMooseの実装がもっとも成熟しているので、あまりリンクするべきところもないのですが、多少なりとも見る価値があるものを紹介します(ほとんどはPerl 6関連のものです)。</p>
		<p>
			<dl>
				<dt><a href="http://www.oreillynet.com/onlamp/blog/2006/08/roles_composable_units_of_obje.html">http://www.oreillynet.com/onlamp/blog/2006/08/roles_composable_units_of_obje.html</a></dt>
				<dd>
					<p>これはchromaticによるロールの解説です。彼は中心的な旗振り役のひとりでした（です）から、一読の価値はあります。</p>
				</dd>
				<dt><a href="http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod">http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod</a></dt>
				<dd>
					<p>このPerl 6の概要第12章ではPerl 6のオブジェクトシステムの全貌が語られているのですが、もちろんここにはロールについての話も含まれています。</p>
				</dd>
			</dl>
		</p>
	</dd>
</dl>

</div>
<h2 id="-11">作者</h2>
<div id="CONTENT-11">
<p>Stevan Little &lt;stevan@iinteractive.com&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2007-2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>
<ul class="sub-navi">
<li><img src="http://lazy-css.org/css/img/inq.png" alt="お問い合わせ"></li>
</ul>

<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

