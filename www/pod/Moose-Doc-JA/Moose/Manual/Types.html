<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<title>Moose::Manual::Types Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css">
</head>
<body>

	
<h1>Moose::Manual::Types</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <a href="/Moose/Manual/Types.html">Moose::Manual::Types</a></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#Perl">Perlで型?</a></li>
<li><a href="#-2">型</a></li>
<li><a href="#-3">型とはなにか</a></li>
<li><a href="#-4">サブタイプ</a>
<ul>
<li>
<ul><li><a href="#-5">（サブタイプではない）新しい型を作る</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#-6">型の名前</a></li>
<li><a href="#-7">型変換</a>
<ul>
<li>
<ul><li><a href="#-8">再帰的な型変換</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#-9">型結合</a></li>
<li><a href="#-10">型を生成するためのヘルパー関数</a></li>
<li><a href="#-11">無名の型</a></li>
<li><a href="#-12">検証メソッドのパラメータ</a></li>
<li><a href="#-13">ロード順の問題</a></li>
<li><a href="#-14">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Manual::Types - Mooseの型システム</p>

</div>
<h2 id="Perl">Perlで型?</h2>
<div id="Perl_CONTENT">
<p>Mooseはアトリビュートのために独自の型システムを用意しています。また、MooseXモジュールの助けを借りるとこれらの型をメソッドのパラメータの検証に使うこともできます。</p>
<p>Mooseの型システムのもとになったのは、Perl 5自身の「暗黙の」型と、Perl 6のいくつかのコンセプトを組み合わせたものです。独自の制約を使うと自前のサブタイプを簡単に作れるため、どのような種類の検証コードでも簡単に表現できます。</p>
<p>型には名前がついているので、名指しで再利用できます。そのため、大きなアプリケーション全体で型を共有することも簡単にできます。</p>
<p>ただし、ここで明確にしておきたいのは、これは「本当の」型システムではないということ。Mooseを使うと魔法の力でPerlが型と変数を関連づけるようになるわけではありません。これは単に名前と制約を関連づけられる高度なパラメータチェックシステムにすぎないのです。</p>
<p>とはいえ、これは本当に便利なものですし、Mooseを楽しく、強力にしている機能のひとつだと思っています。型システムを活用すると、確実に有効なデータを得られるようにするのがはるかに簡単になりますし、コードの保守性にも大きく貢献します。</p>

</div>
<h2 id="-2">型</h2>
<div id="CONTENT-2">
<p>基本的なMooseの型階層はこのようになります。</p>
<pre>  Any
  Item
      Bool
      Maybe[`a]
      Undef
      Defined
          Value
              Num
                Int
              Str
                ClassName
                RoleName
          Ref
              ScalarRef
              ArrayRef[`a]
              HashRef[`a]
              CodeRef
              RegexpRef
              GlobRef
                FileHandle
              Object
                Role

</pre>
<p>実用的には、<code>Any</code>と<code>Item</code>の違いは概念的なものでしかありません（<code>Item</code>は型階層の最上位の型として扱われます）。</p>
<p>それ以外の型は既存のPerlの概念に対応しています。たとえば、<code>Num</code>はPerlが数字だとみなすものすべてであり、<code>Object</code>はblessされたリファレンスである、という具合です。</p>
<p>型のあとに「[`a]」と書いてあるのはパラメータを指定できるものです。だから、単に素の<code>ArrayRef</code>がほしいと書くかわりに、<code>ArrayRef[Int]</code>がほしいと書けるわけです（それどころか、<code>HashRef[ArrayRef[Str]]</code>のようなこともできます）。</p>
<p>特筆に値するのは<code>Maybe[`a]</code>という型です。単独で使うと本当に何の意味もないのですが（<code>Item</code>と同等になります）、パラメータを指定すると、<code>undef</code>かパラメータで指定した型の値をとる、という意味になります（だから、<code>Maybe[Int]</code>であれば整数か<code>undef</code>になります）。</p>
<p>型階層の詳細については<cite>Moose::Util::TypeConstraints</cite>をご覧ください。</p>

</div>
<h2 id="-3">型とはなにか</h2>
<div id="CONTENT-3">
<p>大事なのは、型はクラス（やパッケージ）ではないということです。型は名前と制約を持った単なるオブジェクト（正確にいうなら<cite>Moose::Meta::TypeConstraint</cite>のオブジェクト）にすぎません。Mooseは、<code>Num</code>のような名前を適切なオブジェクトに変換できるように、グローバルな型レジストリを持っています。</p>
<p>ただし、クラス名が型の名前になることは「ありえます」。Mooseを使って新しいクラスを定義すると、裏ではそのクラスに関連づけられた型の名前が定義されます。</p>
<pre>  package MyApp::User;

  use Moose;

</pre>
<p>こうすると、<code>'MyApp::User'</code>が型の名前として使えるようになります。</p>
<pre>  has creator =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'MyApp::User',
  );

</pre>
<p>ただし、Mooseを使っていないクラスの場合、魔法がきかないので、クラス型を明示的に宣言する必要があるかもしれません。いささかややこしいことに、Mooseはアトリビュートの<code>isa</code>の値として未知の型の名前が渡されるとクラスであると仮定するので、これはうまくいきます。</p>
<pre>  has 'birth_date' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'DateTime',
  );

</pre>
<p>一般的に、Mooseは未知の名前を渡すとクラスを指しているものと仮定します。</p>
<pre>  subtype 'ModernDateTime'
      =&gt; as 'DateTime'
      =&gt; where { $_-&gt;year() &gt;= 1980 }
      =&gt; message { 'The date you provided is not modern enough' };

  has 'valid_dates' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'ArrayRef[DateTime]',
  );

</pre>
<p>だから、どちらの場合も、<code>DateTime</code>はクラス名であるとみなされます。</p>

</div>
<h2 id="-4">サブタイプ</h2>
<div id="CONTENT-4">
<p>サブタイプは、Mooseの組み込みの階層でも利用されています（たとえば、<code>Int</code>は<code>Num</code>の子です）。</p>
<p>サブタイプは親の型や制約によって定義されます。親が定義している制約があれば先にそれがチェックされ、それからサブタイプが定義している制約がチェックされます。これらのチェックを「すべて」満たさないと、そのサブタイプの有効な値とはみなされません。</p>
<p>典型的なサブタイプは、親の制約を受け継いでより具体的なものにします。</p>
<p>また、サブタイプには制約を満たさなかったときのために独自のメッセージを定義できます。これを使うと「入力された値(20)は有効な評価ではありません。1～10までの数を入れてください」といったエラーを表示させられます（これは、その値は型の検証チェックに失敗しましたとしか言ってくれないデフォルトのエラーよりはるかに親切です）。</p>
<p>これは簡単な（しかも役に立つ）サブタイプの例です。</p>
<pre>  subtype 'PositiveInt'
      =&gt; as 'Int'
      =&gt; where { $_ &gt; 0 }
      =&gt; message { &quot;The number you provided, $_, was not a positive number&quot; }

</pre>
<p>なお、型を扱うためのシュガー関数はすべて<cite>Moose::Util::TypeConstraints</cite>がエクスポートしています。</p>

</div>
<h3 id="-5">（サブタイプではない）新しい型を作る</h3>
<div id="CONTENT-5">
<p>新たに最上位の型を作ることもできます。</p>
<pre>  type 'FourCharacters' =&gt; where { defined $_ &amp;&amp; length $_ == 4 };

</pre>
<p>実用上、これは<code>Str</code>をサブタイプ化するのと大差ありません（ただし、値が定義されているかどうかは自分でチェックしなければなりません）。</p>
<p><code>Defined</code>や<code>Ref</code>、<code>Object</code>のように非常に大まかな型をサブタイプ化するだけではすまない場合があるとはあまり考えられません。</p>
<p>新たに最上位の型を定義するのは、概念的には<code>Item</code>をサブタイプ化するのと同じことです。</p>

</div>
<h2 id="-6">型の名前</h2>
<div id="CONTENT-6">
<p>型の名前は、現在実行中のPerlインタプリタ全体に影響を及ぼすグローバルなものです。内部的には、Mooseは<b>レジストリ</b> (<cite>Moose::Meta::TypeConstraint::Registry</cite>)を通じて型の名前を型オブジェクトにマッピングします。</p>
<p>同じプロセス内にMooseを使っているアプリケーションやライブラリが複数ある場合、名前の衝突による問題が起こるかもしれません。この種の衝突を防ぐために、型の名前には何らかの名前空間を示すプレフィックスをつけることをおすすめします。</p>
<p>たとえば、型に「PositiveInt」という名前をつけるかわりに「MyApp::Type::PositiveInt」や「MyApp::Types::PositiveInt」と名付けてください。このような型の定義はすべて<code>MyApp::Types</code>というひとつのパッケージにまとめて、アプリケーションのほかのクラスからもロードできるようにすることをおすすめします。</p>

</div>
<h2 id="-7">型変換</h2>
<div id="CONTENT-7">
<p>Mooseの型システムでもっとも強力な機能のひとつが、型変換です。型変換は、ある型を別の型に変える方法のひとつです。</p>
<pre>  subtype 'ArrayRefOfInts'
      =&gt; as 'ArrayRef[Int]';

  coerce 'ArrayRefOfInts'
      =&gt; from 'Int'
      =&gt; via { [ $_ ] };

</pre>
<p>お気づきの通り、ここは<code>ArrayRef[Int]</code>を直接型変換するのではなく、サブタイプを作らなければならないところでした（この辺はちょっとわかりづらいところです）。</p>
<p>型変換も、型の名前と同じくグローバルなものです（これが型の名前に名前空間をつけた方がよい「もうひとつの」理由です）。Mooseは、明示的に指示しない限り「決して」値を型変換しようとはしません。型変換を指示するには、<code>coerce</code>というアトリビュートオプションを真値にセットします。</p>
<pre>  package Foo;

  has 'sizes' =&gt; (
      is     =&gt; 'ro',
      isa    =&gt; 'ArrayRefOfInts',
      coerce =&gt; 1,
  );

  Foo-&gt;new( sizes =&gt; 42 );

</pre>
<p>このサンプルコードは正しく動作します。新しく作ったオブジェクトの<code>sizes</code>アトリビュートの値は<code>[ 42 ]</code>になります。</p>

</div>
<h3 id="-8">再帰的な型変換</h3>
<div id="CONTENT-8">
<p>再帰的な型変換というのは、パラメータ付きの型の型パラメータを型変換することです。このような型を例に取ってみましょう。</p>
<pre>  subtype 'HexNum'
      =&gt; as 'Str'
      =&gt; where { /[a-f0-9]/i };

  coerce 'Int'
      =&gt; from 'HexNum'
      =&gt; via { hex $_ };

  has 'sizes' =&gt; (
      is     =&gt; 'ro',
      isa    =&gt; 'ArrayRef[Int]',
      coerce =&gt; 1,
  );

</pre>
<p><code>sizes</code>アトリビュートに16進数の配列リファレンスを渡そうとしても、Mooseは型変換してくれません。</p>
<p>ただし、サブタイプをひと組定義すると、パラメータ付きの型同士の型変換を有効にすることができます。</p>
<pre>  subtype 'ArrayRefOfHexNums'
      =&gt; as 'ArrayRef[HexNum]';

  subtype 'ArrayRefOfInts'
      =&gt; as 'ArrayRef[Int]';

  coerce 'ArrayRefOfInts'
      =&gt; from 'ArrayRefOfHexNums'
      =&gt; via { [ map { hex } @{$_} ] };

  Foo-&gt;new( sizes =&gt; [ 'a1', 'ff', '22' ] );

</pre>
<p>これでMooseは16進数を整数に型変換してくれるようになりました。</p>
<p>ただし、Mooseは型変換を連鎖的に実行してくれるわけではないので、このままでは単独の16進数の型変換はしてくれません。これをさせるには、別の型変換を定義する必要があります。</p>
<pre>  coerce 'ArrayRefOfInts'
      =&gt; from 'HexNum'
      =&gt; via { [ hex $_ ] };

</pre>
<p>たしかにこれは非常に冗長になってしまうこともありますが、型変換はトリッキーな魔法ですから、明示的にしておくのがいちばんだと思っています。</p>

</div>
<h2 id="-9">型結合</h2>
<div id="CONTENT-9">
<p>Mooseを使うと、複数の異なる型になれるアトリビュートを定義することができます。たとえば、ここでは<code>Object</code>か<code>FileHandle</code>なら認めてもよい、というわけです。</p>
<pre>  has 'output' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Object | FileHandle',
  );

</pre>
<p>Mooseは実際にその文字列を解析して、型結合を作っていることを認識すると、<code>output</code>アトリビュートにはあらゆる種類のオブジェクトと、blessされていないファイルハンドルを受け入れるようにさせます。自分のコードの中でそのそれぞれについて正しい処理を行うのはみなさんの仕事です。</p>
<p>型結合を使う場合はかならず型変換の方がよい解決策ではないか検討するようにしてください。</p>
<p>上の例の場合、もっと具体的に、outputは<code>print</code>メソッドを持つオブジェクトでなければならないと定義した方がよいかもしれません。</p>
<pre>  subtype 'CanPrint'
      =&gt; as 'Object'
      =&gt; where { $_-&gt;can('print') };

</pre>
<p>簡単なラッパクラスを使えば、ファイルハンドルをこの条件を満たすオブジェクトに型変換することもできます。</p>
<pre>  package FHWrapper;

  use Moose;

  has 'handle' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'FileHandle',
  );

  sub print {
      my $self = shift;
      my $fh   = $self-&gt;handle();

      print $fh @_;
  }

</pre>
<p>これで<code>FileHandle</code>からこのラッパクラスへの型変換を定義できるようになりました。</p>
<pre>  coerce 'CanPrint'
      =&gt; from 'FileHandle'
      =&gt; via { FHWrapper-&gt;new( handle =&gt; $_ ) };

  has 'output' =&gt; (
      is     =&gt; 'rw',
      isa    =&gt; 'CanPrint',
      coerce =&gt; 1,
  );

</pre>
<p>このように型結合のかわりに型変換を使うと、クラスの内部をよりシンプルにできるようになります。</p>

</div>
<h2 id="-10">型を生成するためのヘルパー関数</h2>
<div id="CONTENT-10">
<p><cite>Moose::Util::TypeConstraints</cite>モジュールは、<code>class_type</code>や<code>role_type</code>、<code>maybe_type</code>のように、特定の種類の型を生成するためのヘルパー関数を多数エクスポートします。詳しくはドキュメントをご覧ください。</p>
<p>特筆に値するヘルパーとしては、<code>enum</code>があります。これを使うと、指定した値しか許さない<code>Str</code>型のサブタイプを生成できます。</p>
<pre>  enum 'RGB' =&gt; qw( red green blue );

</pre>
<p>これで<code>RGB</code>という名前の型が生成されます。</p>

</div>
<h2 id="-11">無名の型</h2>
<div id="CONTENT-11">
<p>型を生成する関数はすべて型オブジェクトを返します。この型オブジェクトは、親の型や、アトリビュートの<code>isa</code>オプションの値のように、型の名前を使える場所ならどこででも使えます。</p>
<pre>  has 'size' =&gt; (
      is =&gt; 'ro',
      isa =&gt; subtype 'Int' =&gt; where { $_ &gt; 0 },
  );

</pre>
<p>これは、その場限りの型を作る（グローバルな名前空間レジストリを「汚染」したくない）ときに便利です。</p>

</div>
<h2 id="-12">検証メソッドのパラメータ</h2>
<div id="CONTENT-12">
<p>Mooseには検証メソッドにパラメータを渡す手段はありませんが、CPANにはこれをできるようにするMooseX拡張モジュールがいくつかあります。</p>
<p>もっとも簡単で、甘さ控えめなのは<cite>MooseX::Params::Validate</cite>です。このモジュールを使うと、名前付きパラメータの組を検証するときにMooseの型を使えます。</p>
<pre>  use Moose;
  use MooseX::Params::Validate;

  sub foo {
      my $self   = shift;
      my %params = validated_hash(
          \@_,
          bar =&gt; { isa =&gt; 'Str', default =&gt; 'Moose' },
      );
      ...
  }

</pre>
<p><cite>MooseX::Params::Validate</cite>は型変換もサポートしています。</p>
<p>Mooseの型を使ったメソッドパラメータの検証をサポートしている拡張モジュールの中には、ほかにももっと強力ながいくつかあります。そのひとつである<cite>MooseX::Method::Signatures</cite>は、本格的な<code>method</code>キーワードを提供してくれます。</p>
<pre>  method morning (Str $name) {
      $self-&gt;say(&quot;Good morning ${name}!&quot;);
  }

</pre>

</div>
<h2 id="-13">ロード順の問題</h2>
<div id="CONTENT-13">
<p>Mooseの型は実行時に定義されるので、ロード順の問題に遭遇することがあります（特に、定義される前にクラス型の制約を使おうとしてしまうことがあります）。</p>
<p>この問題にはいくつかおすすめの解決策があります。まず、独自の型は「すべて」<code>MyApp::Types</code>というモジュールに定義してください。次に、このモジュールを、ほかのすべてのモジュールでロードするようにしてください。</p>
<p>それでもまだロード順の問題が起こる場合は、<cite>Moose::Util::TypeConstraints</cite>がエクスポートしている<code>find_type_constraint</code>を使う手もあります。</p>
<pre>  class_type('MyApp::User')
      unless find_type_constraint('MyApp::User');

</pre>
<p>このような「なければ作る」というロジックは、書くのも簡単ですし、ロード順の問題の対策にもなります。</p>

</div>
<h2 id="-14">作者</h2>
<div id="CONTENT-14">
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>


<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>

	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

