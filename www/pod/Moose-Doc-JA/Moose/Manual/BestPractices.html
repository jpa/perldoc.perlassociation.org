<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Moose::Manual::BestPractices Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css" />
</head>
<body>
<h1>Moose::Manual::BestPractices</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <a href="/Moose/Manual/BestPractices.html">Moose::Manual::BestPractices</a></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">推薦の言葉</a>
<ul>
<li>
<ul><li><a href="#code_no_Moose_code"><code>no Moose</code>と不変化</a></li>
<li><a href="#code_new_code"><code>new</code>はオーバーライドしないこと</a></li>
<li><a href="#code_SUPER_BUILDARGS_code">かならず<code>SUPER::BUILDARGS</code>を呼ぶこと</a></li>
<li><a href="#code_required_code">できればかならずデフォルトを用意すること、そうでなければ<code>required</code>を使うこと</a></li>
<li><a href="#code_default_code_code_builder_code">よほどのことがなければ<code>default</code>のかわりに<code>builder</code>を使うこと</a></li>
<li><a href="#code_lazy_build_code"><code>lazy_build</code>を使うこと</a></li>
<li><a href="#-3">クリア用のメソッドや断定用のメソッドはプライベートにすることを検討すること</a></li>
<li><a href="#-4">デフォルトは読み取り専用にして、書き込み用のアクセサはプライベートにすることを検討すること</a></li>
<li><a href="#-5">サブクラスでアトリビュートの型を変える前にもう一度考え直すこと</a></li>
<li><a href="#code_initializer_code"><code>initializer</code>機能は使わないこと</a></li>
<li><a href="#code_auto_deref_code_cite_MooseX_Att"><code>auto_deref</code>のかわりに<cite>MooseX::AttributeHelpers</cite>を使うこと</a></li>
<li><a href="#code_inner_code">もっとも具体的なサブクラスであってもかならず<code>inner</code>を呼ぶこと</a></li>
<li><a href="#-6">型には名前空間を付けること</a></li>
<li><a href="#Moose">Mooseの組み込み型は直接型変換しないこと</a></li>
<li><a href="#-7">クラス名を直接型変換しないこと</a></li>
<li><a href="#-8">型結合のかわりに型変換を使うこと</a></li>
<li><a href="#-9">型の定義はすべてひとつのモジュールにまとめること</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#-10">ベストプラクティスの効用</a></li>
<li><a href="#-11">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Manual::BestPractices - Mooseを最大限に活用する</p>

</div>
<h2 id="-2">推薦の言葉</h2>
<div id="CONTENT-2">
<p>Mooseにはさまざまな機能がありますし、使い方も決して一通りではありません。でも、使う機能は一部にしぼって、いつもそれを使うようにした方が、みなさんのためになると思います。</p>
<p>もちろんどんな「ベストプラクティス」集でもそうですが、これも本当にただの意見にすぎませんので、無視していただいても結構です。</p>

</div>
<h3 id="code_no_Moose_code"><code>no Moose</code>と不変化</h3>
<div id="code_no_Moose_code_CONTENT">
<p>Mooseのクラス定義の最後にはMooseのシュガー関数を削除してクラスを不変化することをおすすめします。</p>
<pre>  package Person;

  use Moose;

  # extends, roles, attributes, etc.

  # methods

  no Moose;

  __PACKAGE__-&gt;meta-&gt;make_immutable;

  1;

</pre>
<p><code>no Moose</code>の部分は単にコードをきれいにするためのものです。また、クラスを不変化すると、いろいろなものが高速化します（もっとも顕著なのはオブジェクトの生成です）。</p>

</div>
<h3 id="code_new_code"><code>new</code>はオーバーライドしないこと</h3>
<div id="code_new_code_CONTENT">
<p><code>new</code>をオーバーライドするのは非常に悪いことです。同じことをしたいのであれば<code>BUILD</code>メソッドや<code>BUILDARGS</code>メソッドを使ってください。<code>new</code>をオーバーライドすると、クラスを不変化したときにコンストラクタをインライン展開できなくなってしまいます。</p>
<p>ただし、<code>new</code>をオーバーライドしてもよい場合が2つあります。ひとつは、自前で<cite>Moose::Object</cite>のサブクラス「と」<cite>Moose::Meta::Method::Constructor</cite>を用意してコンストラクタをインライン展開するようなMooseX拡張モジュールを書いている場合。2つめはMooseを使っていない親クラスをサブクラス化する場合です。</p>
<p>やり方を知っている人なら、このベストプラクティスを無視してよいときもご存じですよね ;)</p>

</div>
<h3 id="code_SUPER_BUILDARGS_code">かならず<code>SUPER::BUILDARGS</code>を呼ぶこと</h3>
<div id="code_SUPER_BUILDARGS_code_CONTENT">
<p>自分のクラスで<code>BUILDARGS</code>メソッドをオーバーライドする場合はかならず、お行儀よく<code>SUPER::BUILDARGS</code>を呼んで、自分では明示的にチェックしていないケースを処理するようにしてください。</p>
<p><cite>Moose::Object</cite>が提供しているデフォルトの<code>BUILDARGS</code>メソッドは名前付きパラメータのリストとハッシュリファレンスをどちらも正しく処理できます。また、「ハッシュリファレンス以外の」引数がひとつだけの場合もチェックしてくれます。</p>

</div>
<h3 id="code_required_code">できればかならずデフォルトを用意すること、そうでなければ<code>required</code>を使うこと</h3>
<div id="code_required_code_CONTENT">
<p>クラスにデフォルト値が用意されていると新しいオブジェクトを生成するのが簡単になります。デフォルトを用意できない場合はアトリビュートを<code>required</code>にすることを検討してください。</p>
<p>どちらもしないと、アトリビュートが単にセットされていないだけという状態になることがあるため、オブジェクトがより複雑なものになってしまいます（みなさんや、みなさんのクラスのユーザが考慮しなければならない状態の可能性が増えてしまうためです）。</p>

</div>
<h3 id="code_default_code_code_builder_code">よほどのことがなければ<code>default</code>のかわりに<code>builder</code>を使うこと</h3>
<div id="code_default_code_code_builder_code_">
<p>ビルダーは継承可能ですし、明示的な名前がついています。とにかくこちらの方が明らかにきれいなのです。</p>
<p>ただし、デフォルトがリファレンスでない場合、「あるいは」デフォルトが何らかの空のリファレンスでしかない場合は、「ぜひ」デフォルトを使ってください。</p>
<p>また、ビルダーメソッドはプライベートにしておいてください。</p>

</div>
<h3 id="code_lazy_build_code"><code>lazy_build</code>を使うこと</h3>
<div id="code_lazy_build_code_CONTENT">
<p>遅延評価は便利ですし、初期化の順番の問題を解決してくれることも多いものです。また、まったくする必要がないかもしれない作業を遅らせるときにも使えます。遅延評価をさせたい場合は、<i>lazy_build</i>を使うと、タイプ数を節約して、名前も標準化できるようになります。</p>

</div>
<h3 id="-3">クリア用のメソッドや断定用のメソッドはプライベートにすることを検討すること</h3>
<div id="CONTENT-3">
<p>「本当に」だれでもアトリビュートをクリアできるようになっている必要はあるでしょうか。おそらくないはずです。この機能をデフォルトでクラスの外から見えるようにするのはやめましょう。</p>
<p>断定用のメソッドの方はそれほど問題ではありませんが、わざわざ必要以上に公開APIを大きくする理由はありません。</p>

</div>
<h3 id="-4">デフォルトは読み取り専用にして、書き込み用のアクセサはプライベートにすることを検討すること</h3>
<div id="CONTENT-4">
<p>アトリビュートを可変化すると、単純にプログラムの中で考慮しなければならない複雑さが増してしまいます。状態を可変化するかわりに、クラスのユーザには必要があれば新しいオブジェクトを作るようすすめてください。</p>
<p>どうしてもアトリビュートを読み書き可能に「しなければならない」場合は、書き込み用のアクセサを別のプライベートメソッドにしてしまうことを検討してください。APIの幅を狭めた方がメンテナンスがしやすくなりますし、状態が可変になっているとトラブルのもとです。</p>

</div>
<h3 id="-5">サブクラスでアトリビュートの型を変える前にもう一度考え直すこと</h3>
<div id="CONTENT-5">
<p>その道の先にあるのは大混乱です。アトリビュート自身がオブジェクトの場合、少なくとも親クラスのオブジェクトの型と同じインタフェースを持っているかどうかは確認しましょう。</p>

</div>
<h3 id="code_initializer_code"><code>initializer</code>機能は使わないこと</h3>
<div id="code_initializer_code_CONTENT">
<p>何を言っているのかわからない?　大丈夫です。</p>

</div>
<h3 id="code_auto_deref_code_cite_MooseX_Att"><code>auto_deref</code>のかわりに<cite>MooseX::AttributeHelpers</cite>を使うこと</h3>
<div id="code_auto_deref_code_cite_MooseX_Att-2">
<p><code>auto_deref</code>はいささかやっかいな機能ですし、複雑なアトリビュートを直接外に見せるのは美しくありません。かわりに<cite>MooseX::AttributeHelpers</cite>を使って、そうする必要がある機能のみを外に見せるようなAPIを定義することを検討してください。そうすれば、ほしい機能のみを外に見せることができるようになります。</p>

</div>
<h3 id="code_inner_code">もっとも具体的なサブクラスであってもかならず<code>inner</code>を呼ぶこと</h3>
<div id="code_inner_code_CONTENT">
<p><code>augment</code>と<code>inner</code>を使う場合は、階層内でもっとも具体的なサブクラスの中でも<code>inner</code>を呼ぶことをおすすめします。こうしておくと、親クラスを変更しなくてもさらにサブクラス化を進めて階層を拡張することができるようになります。</p>

</div>
<h3 id="-6">型には名前空間を付けること</h3>
<div id="CONTENT-6">
<p>型の名前には何らかの命名規則を適用してください。「MyApp::Type::Foo」のようなものがおすすめです。</p>
<p>あとから再利用できるように<cite>MooseX::Types</cite>を使って型をパッケージングするつもりがあるなら、空白やピリオドのようにPerlの識別名としては使えない文字は使わないようにしてください。</p>

</div>
<h3 id="Moose">Mooseの組み込み型は直接型変換しないこと</h3>
<div id="Moose_CONTENT">
<p><code>ArrayRef</code>のようなMooseの組み込み型に型変換を定義すると、この型を利用しているPerlインタプリタ上で動作しているすべてのアプリケーションに影響を及ぼします。</p>
<pre>    # very naughty!
    coerce 'ArrayRef'
        =&gt; from Str
        =&gt; via { [ split /,/ ] };

</pre>
<p>だから、そのかわりにサブタイプを作って、そちらを型変換してください。</p>
<pre>    subtype 'My::ArrayRef' =&gt; as 'ArrayRef';

    coerce 'My::ArrayRef'
        =&gt; from 'Str'
        =&gt; via { [ split /,/ ] };

</pre>

</div>
<h3 id="-7">クラス名を直接型変換しないこと</h3>
<div id="CONTENT-7">
<p>Mooseの組み込み型の場合とまったく同じで、クラス型もインタプリタ全体に影響を及ぼすグローバルなものなので、クラス名に型変換を追加してしまうと、よそで不思議な副作用を引き起こすことがあります。</p>
<pre>    # also very naughty!
    coerce 'HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };

</pre>
<p>そうするかわりに、型変換用に「空の」サブタイプを作成できます。</p>
<pre>    subtype 'My::HTTP::Headers' =&gt; as class_type('HTTP::Headers');

    coerce 'My::HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };

</pre>

</div>
<h3 id="-8">型結合のかわりに型変換を使うこと</h3>
<div id="CONTENT-8">
<p>型結合のかわりに型変換を使うことを検討してください。これについては<cite>Moose::Manual::Types</cite>で詳しく取り上げています。</p>

</div>
<h3 id="-9">型の定義はすべてひとつのモジュールにまとめること</h3>
<div id="CONTENT-9">
<p>型や型変換はすべてひとつのモジュールの中で定義してください。これも<cite>Moose::Manual::Types</cite>で説明しました。</p>

</div>
<h2 id="-10">ベストプラクティスの効用</h2>
<div id="CONTENT-10">
<p>このようなベストプラクティスにしたがうと、さまざまな利益が得られます。</p>
<p>ほかのコードとの相性が確実によくなるよう手助けをしてくれるので、コードの再利用性が高まり、拡張しやすくなります。</p>
<p>定評のある慣用句を使うことでメンテナンスが簡単になりますし（ほかの人にメンテナンスしてもらわなければならなくなったときは特にそうです）、コードをすぐに理解してもらいやすくなるので、ほかのMooseユーザからのサポートも得やすくなります。</p>
<p>また、中にはMooseが適切な処理をするのを支援するためのものもあります（特に不変化についての話がそうです。不変化すると、コードが速くなります）。</p>
<p>メタプログラミングを最大限に活用する手助けをするものもたくさんあります。本当の型変換を定義するかわりに<code>new</code>をオーバーライドして手作業で型変換していては、イントロスペクション可能なメタデータは得られません。MooseXの拡張モジュールがイントロスペクションを頼りに適切な処理をしている場合は特にこのようなことが問題になります。</p>

</div>
<h2 id="-11">作者</h2>
<div id="CONTENT-11">
<p>Yuval (nothingmuch) Kogman</p>
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>
<ul class="sub-navi">
<li><img src="http://lazy-css.org/css/img/inq.png" alt="お問い合わせ"></li>
</ul>

<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

