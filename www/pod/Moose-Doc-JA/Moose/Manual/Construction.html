<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Japan Perl Association CPAN和訳ドキュメント">
<meta name="keyword" content="perl,cpan,jpa,和訳,日本語訳">
<title>Moose::Manual::Construction Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css" />
</head>
<body>
<h1>Moose::Manual::Construction</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <strong>Moose::Manual::Construction</strong></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">コンストラクタはどこにありますか</a></li>
<li><a href="#-3">オブジェクトの生成とアトリビュート</a></li>
<li><a href="#-4">オブジェクト生成時の割り込み</a>
<ul>
<li>
<ul><li><a href="#BUILDARGS">BUILDARGS</a></li>
<li><a href="#BUILD">BUILD</a>
<ul><li><a href="#BUILD-2">BUILDと親クラス</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#-5">オブジェクトの破棄</a></li>
<li><a href="#-6">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Manual::Construction - Mooseを使ったオブジェクトの生成（と破棄）</p>

</div>
<h2 id="-2">コンストラクタはどこにありますか</h2>
<div id="CONTENT-2">
<p><strong>自分のクラスには<code>new()</code>メソッドを定義しないでください!</strong></p>
<p><code>use Moose</code>したクラスは<cite>Moose::Object</cite>のサブクラスになるのですが、<code>new</code>メソッドはこの<cite>Moose::Object</cite>が用意してくれます。<cite>Moose::Manual::BestPractices</cite>のおすすめ通りにクラスを不変化した場合は、そのクラス専用の<code>new</code>メソッドがクラスの中に実際に「インライン展開」されます。</p>

</div>
<h2 id="-3">オブジェクトの生成とアトリビュート</h2>
<div id="CONTENT-3">
<p>Mooseが提供するコンストラクタはアトリビュートに対応する（実際にはアトリビュートの<code>init_arg</code>に対応する）名前付きパラメータのハッシュないしハッシュリファレンスを受け付けます。これもまたMooseを使うとクラスが「どのように」実装されているか心配しなくてよくなる理由のひとつです。クラスを定義しさえすればオブジェクトを生成できるようになるのです!</p>

</div>
<h2 id="-4">オブジェクト生成時の割り込み</h2>
<div id="CONTENT-4">
<p>Mooseを使うとオブジェクト生成時に割り込みをかけることもできます（オブジェクトの状態を検証したり、ログを取ったり、おそらくハッシュ（リファレンス）以外のコンストラクタ引数を許すようにもできます）。そうする場合は、<code>BUILD</code>メソッドや<code>BUILDARGS</code>メソッドを作ってください。</p>
<p>これらのメソッドがクラスに存在している場合、Mooseはオブジェクト生成プロセスの途中でこれらのメソッドを呼ぶよう手配してくれます。</p>

</div>
<h3 id="BUILDARGS">BUILDARGS</h3>
<div id="BUILDARGS_CONTENT">
<p><code>BUILDARGS</code>メソッドは、オブジェクトが生成される「前に」、クラスメソッドとして呼ばれます。<code>BUILDARGS</code>メソッドは、<code>new</code>に渡されたすべての引数を「そのままの形で」受け取り、ハッシュリファレンスを返すことが期待されています。このハッシュリファレンスはオブジェクトを生成するときに使うので、アトリビュート名（というか<code>init_arg</code>）に対応したキーを入れておくようにしてください。</p>
<p><code>BUILDARGS</code>は、ハッシュ（リファレンス）以外の呼び出し方に対応させるときによく使われます。たとえば、Personクラスは<code>Person-&gt;new($ssn)</code>のように社会保障番号ひとつで呼べるようにしたい場合があるかもしれません。</p>
<p>この場合、<code>BUILDARGS</code>メソッドがないと、Mooseは（ハッシュまたはハッシュリファレンスを期待しているので）エラーを発生させますが、<code>BUILDARGS</code>メソッドを使うとこの呼び出し方に対応できます。</p>
<pre>  sub BUILDARGS {
      my $class = shift;

      if ( @_ == 1 &amp;&amp; ! ref $_[0] ) {
          return { ssn =&gt; $_[0] };
      }
      else {
          return $class-&gt;SUPER::BUILDARGS(@_);
      }
  }

</pre>
<p><code>SUPER::BUILDARGS</code>を呼んでいることに注意してください。これは<cite>Moose::Object</cite>にデフォルトで用意されている<code>BUILDARGS</code>を呼ぶものです。このメソッドを使うとハッシュリファレンスとただのハッシュを区別してくれます。</p>

</div>
<h3 id="BUILD">BUILD</h3>
<div id="BUILD_CONTENT">
<p><code>BUILD</code>メソッドはオブジェクトが生成された「あとに」呼ばれます。<code>BUILD</code>メソッドの使い方はいくつかありますが、もっともよくあるのは、オブジェクトの状態が有効かどうかチェックするものです（型を使えば個々のアトリビュートの検証はできますが、オブジェクト全体の状態についてはその方法では検証できません）。</p>
<pre>  sub BUILD {
      my $self = shift;

      if ( $self-&gt;country_of_residence eq 'USA' ) {
          die 'All US residents must have an SSN'
              unless $self-&gt;has_ssn;
      }
  }

</pre>
<p><code>BUILD</code>メソッドのほかの使い方としては、オブジェクトを生成したときのログ取りやトラッキングがあげられます。</p>
<pre>  sub BUILD {
      my $self = shift;

      debug( 'Made a new person - SSN = ', $self-&gt;ssn, );
  }

</pre>

</div>
<h4 id="BUILD-2">BUILDと親クラス</h4>
<div id="BUILD_CONTENT-2">
<p>継承階層に複数の<code>BUILD</code>メソッドがある場合、Perlのふつうのメソッドとは相互作用の仕方が異なるので、<strong>決して<code>$self-&gt;SUPER::BUILD</code>は呼ばないようにしてください。</strong></p>
<p>Mooseは、オブジェクトを生成するとき、階層内にあるすべての<code>BUILD</code>メソッドを「親から子の順番で」呼ぶよう手配します（最初は驚くかもしれませんが、通常のメソッド継承の順番とは逆なのです）。</p>
<p>このようになっているのは、<code>BUILD</code>メソッドはクラスの制約の特殊性を増すことにしか使えないため、もっとも抽象的な<code>BUILD</code>から呼んでいく方が理にかなっているからです（なお、Perl 6もそのようになっています）。</p>

</div>
<h2 id="-5">オブジェクトの破棄</h2>
<div id="CONTENT-5">
<p>Mooseを使うと、オブジェクトを破棄するときも<code>DEMOLISH</code>メソッドで割り込みをかけられます。<code>BUILD</code>の場合と同じく、明示的に<code>$self-&gt;SUPER::DEMOLISH</code>を呼ぶことは決してしないでください。Mooseは階層内のすべての<code>DEMOLISH</code>メソッドを、もっとも具体的なクラスからもっとも抽象的なクラスの順に呼ぶよう手配します。</p>
<p>ただし、たいていの場合はPerlに組み込まれているガベージコレクションで十分です。<code>DEMOLISH</code>メソッドを用意する必要はありません。</p>

</div>
<h2 id="-6">作者</h2>
<div id="CONTENT-6">
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>
<ul class="sub-navi">
<li><img src="http://lazy-css.org/css/img/inq.png" alt="お問い合わせ"></li>
</ul>

<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

