<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Moose::Manual::Roles Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css" />
</head>
<body>
<h1>Moose::Manual::Roles</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <a href="/Moose/Manual/Roles.html">Moose::Manual::Roles</a></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">ロールとは</a></li>
<li><a href="#-3">簡単なロール</a></li>
<li><a href="#-4">必須メソッド</a>
<ul>
<li>
<ul><li><a href="#vs">ロールvs抽象ベースクラス</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#-5">メソッドモディファイアを使う</a></li>
<li><a href="#-6">メソッドの衝突</a></li>
<li><a href="#-7">メソッドの排除と別名</a></li>
<li><a href="#-8">ロールの排除</a></li>
<li><a href="#-9">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Manual::Roles - ロール：深い階層やベースクラスのかわりに</p>

</div>
<h2 id="-2">ロールとは</h2>
<div id="CONTENT-2">
<p>ロールというのはクラスが行う役割をあらわすものです。ロールはふつう、クラス間で共有できるなんらかの振る舞いや状態をカプセル化しますが、大切なのは「ロールはクラスではない」ということです。ロールは継承できませんし、インスタンス化することもできません（ロールはクラスやほかのロールによって「消費」されてしまうという言い方をすることもあります）。</p>
<p>そのかわり、ロールはクラスに「合成」できます。実用的な言い方をすると、ロールの中で定義されているメソッドやアトリビュートはすべて、ロールを取り込んだクラスにそのまま追加される（「フラット化」されるという言い方をすることもあります）、ということです。このようにして合成したアトリビュートやメソッドは、そのクラス自身に定義されていたかのように見えるようになります。ロールを取り込んだクラスをサブクラス化すると、合成したメソッドやアトリビュートもすべて継承されます。</p>
<p>Mooseのロールは、ほかの言語でいうミックスインやインタフェースに似ています。</p>
<p>ロールは、自前のメソッドやアトリビュートを定義できるだけでなく、取り込む側のクラス自身に特定のメソッドを定義するよう要求することもできます（必須メソッドのリストしかないロールを作ることもできます。その場合、ロールはJavaのインタフェースと非常によく似たものになります）。</p>

</div>
<h2 id="-3">簡単なロール</h2>
<div id="CONTENT-3">
<p>ロールの作り方とMooseのクラスの作り方はよく似ています。</p>
<pre>  package Breakable;

  use Moose::Role;

  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );

  sub break {
      my $self = shift;

      print &quot;I broke\n&quot;;

      $self-&gt;is_broken(1);
  }

</pre>
<p><cite>Moose::Role</cite>を使っていることを除けば、これはMooseを使ったクラス定義にそっくりです。ただし、これはクラスではないのでインスタンス化はできません。</p>
<p>そのかわり、このアトリビュートやメソッドはこのロールを使ったクラスに合成されます。</p>
<pre>  package Car;

  use Moose;

  with 'Breakable';

  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );

</pre>
<p><code>with</code>関数を使うとロールをクラスに合成できます。合成が済むと、<code>Car</code>クラスには<code>is_broken</code>アトリビュートと<code>break</code>メソッドができます。また、<code>Car</code>クラスは<code>does('Breakable')</code>でもあります。</p>
<pre>  my $car = Car-&gt;new( engine =&gt; Engine-&gt;new );

  print $car-&gt;is_broken ? 'Still working' : 'Busted';
  $car-&gt;break;
  print $car-&gt;is_broken ? 'Still working' : 'Busted';

  $car-&gt;does('Breakable'); # true

</pre>
<p>この出力はこうなります。</p>
<pre>  Still working
  I broke
  Busted

</pre>
<p>同じロールを<code>Bone</code>クラスでも使うことができます。</p>
<pre>  package Bone;

  use Moose;

  with 'Breakable';

  has 'marrow' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Marrow',
  );

</pre>

</div>
<h2 id="-4">必須メソッド</h2>
<div id="CONTENT-4">
<p>前述したように、ロールは取り込む側のクラスにひとつ以上のメソッドを提供するように要求できます。<code>Breakable</code>の例を使って、取り込み側のクラスに自前の<code>break</code>メソッドを実装するよう要求することにしましょう。</p>
<pre>  package Breakable;

  use Moose::Role;

  requires 'break';

  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );

  after 'break' =&gt; sub {
      my $self = shift;

      $self-&gt;is_broken(1);
  };

</pre>
<p>このロールを<code>break</code>メソッドのないクラスに取り込もうとすると例外が発生します。</p>
<p>ご覧の通り、<code>break</code>にはメソッドモディファイアを追加しました。このロールを取り込むクラスには自前のbreakロジックを実装してほしいけれど、<code>break</code>が呼ばれたときにはかならず<code>is_broken</code>アトリビュートも真にしたいためです。</p>
<pre>  package Car

  use Moose;

  with 'Breakable';

  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );

  sub break {
      my $self = shift;

      if ( $self-&gt;is_moving ) {
          $self-&gt;stop;
      }
  }

</pre>

</div>
<h3 id="vs">ロールvs抽象ベースクラス</h3>
<div id="vs_CONTENT">
<p>ほかの言語で抽象ベースクラスの概念におなじみの方は、ロールを同じように使いたいと思われるかもしれません。</p>
<p>必須メソッドのリストしかない「インタフェースのみの」ロールを定義することは「できます」。</p>
<p>ただし、そのロールを取り込むクラスは、直接実装するにせよ、親から継承するにせよ、かならずすべての必須メソッドを実装しなければなりません（必須メソッドのチェックを後回しにして、将来サブクラスに実装させるようにはできません）。</p>
<p>ロールは必須メソッドを直接定義しているので、そこにベースクラスを追加しても何の役にも立ちません。インタフェースロールは単純にそのインタフェースを実装しているすべてのクラスで取り込むようにすることをおすすめします。</p>

</div>
<h2 id="-5">メソッドモディファイアを使う</h2>
<div id="CONTENT-5">
<p>メソッドモディファイアとロールは非常に強力な組み合わせです。ロールがメソッドモディファイアと必須メソッドを組み合わせたものになることが多いのは、すでに<code>Breakable</code>の例でも見た通りです。</p>
<p>メソッドモディファイアを使うとロールの複雑さが増します（ロールを組み込む順番が問題になってくるためです）。クラスの中に同じメソッドを修飾するロールが複数ある場合、モディファイアはロールが組み込まれるのと同じ順番で適用されます。</p>
<pre>  package MovieCar;

  use Moose;

  extends 'Car';

  with 'Breakable', 'ExplodesOnBreakage';

</pre>
<p>新しく追加した<code>ExplodesOnBreakage</code>ロール「でも」<code>break</code>に<code>after</code>モディファイアがついている場合、<code>after</code>モディファイアはひとつずつ実行されます（最初に<code>Breakable</code>のモディファイアが実行され、次に<code>ExplodesOnBreakage</code>のモディファイアが実行されます）。</p>

</div>
<h2 id="-6">メソッドの衝突</h2>
<div id="CONTENT-6">
<p>クラスに複数のロールを合成するとき、複数のロールに同名のメソッドがあると衝突が起こります。この場合、合成しようとしているクラスが同名のメソッドを「自分で」提供しなければなりません。</p>
<pre>  package Breakdancer;

  use Moose::Role

  sub break {

  }

</pre>
<p><code>Breakable</code>と<code>Breakdancer</code>をひとつのクラスに合成する場合、自前の<code>break</code>メソッドを用意する必要があります。</p>
<pre>  package FragileDancer;

  use Moose;

  with 'Breakable', 'Breakdancer';

  sub break { ... }

</pre>

</div>
<h2 id="-7">メソッドの排除と別名</h2>
<div id="CONTENT-7">
<p><code>FragileDancer</code>クラスからどちらのロールのメソッドも呼べるようにしたい場合は、メソッドに別名をつける手があります。</p>
<pre>  package FragileDancer;

  use Moose;

  with 'Breakable'   =&gt; { alias =&gt; { break =&gt; 'break_bone' } },
       'Breakdancer' =&gt; { alias =&gt; { break =&gt; 'break_dance' } };

</pre>
<p>ただし、メソッドの別名は単にメソッドを「コピー」して新しいメソッドを作っているだけなので、元の名前を排除しておく必要もあります。</p>
<pre>  with 'Breakable' =&gt; {
      alias   =&gt; { break =&gt; 'break_bone' },
      exclude =&gt; 'break',
      },
      'Breakdancer' =&gt; {
      alias   =&gt; { break =&gt; 'break_dance' },
      exclude =&gt; 'break',
      };

</pre>
<p>excludeパラメータを使うと、<code>break</code>メソッドが<code>FragileDancer</code>クラスに合成されなくなるので衝突は起こりません（つまり、<code>FragileDancer</code>が自前の<code>break</code>メソッドを実装する必要もなくなります）。</p>
<p>これは便利な機能ですが、ロールを取り込むときの暗黙の契約を破ってしまうことにもご注意ください。<code>FragileDancer</code>クラスは、<code>Breakable</code>であり<code>BreakDancer</code>でもあるのに<code>break</code>メソッドがありませんが、どちらかのロールを持つオブジェクトを期待しているAPIがあったら、おそらくこのメソッドが実装されていることも期待しているはずです。</p>
<p>ユースケースによっては、ロールのメソッドは別名を用意して排除したうえで、クラス自身に同名のメソッドを用意させる場合もあります。</p>

</div>
<h2 id="-8">ロールの排除</h2>
<div id="CONTENT-8">
<p>ロールは、合成できないロールを指定することもできます。これはロールの再利用性を制限するのでよく気をつけて利用してください。</p>
<pre>  package Breakable;

  use Moose::Role;

  excludes 'BreakDancer';

</pre>

</div>
<h2 id="-9">作者</h2>
<div id="CONTENT-9">
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>
<ul class="sub-navi">
<li><img src="http://lazy-css.org/css/img/inq.png" alt="お問い合わせ"></li>
</ul>

<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

