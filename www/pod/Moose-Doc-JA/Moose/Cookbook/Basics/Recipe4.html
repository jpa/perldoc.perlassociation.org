<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<title>Moose::Cookbook::Basics::Recipe4 Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css">
</head>
<body>

	
<h1>Moose::Cookbook::Basics::Recipe4</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <a href="/Moose/Cookbook/Basics/Recipe4.html">Moose::Cookbook::Basics::Recipe4</a></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">概要</a></li>
<li><a href="#-3">本文</a></li>
<li><a href="#-4">まとめ</a></li>
<li><a href="#-5">脚注</a></li>
<li><a href="#-6">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Cookbook::Basics::Recipe4 - サブタイプと、簡単な<strong>Company</strong>クラス階層のモデリング</p>

</div>
<h2 id="-2">概要</h2>
<div id="CONTENT-2">
<pre>  package Address;
  use Moose;
  use Moose::Util::TypeConstraints;

  use Locale::US;
  use Regexp::Common 'zip';

  my $STATES = Locale::US-&gt;new;
  subtype 'USState'
      =&gt; as Str
      =&gt; where {
             (    exists $STATES-&gt;{code2state}{ uc($_) }
               || exists $STATES-&gt;{state2code}{ uc($_) } );
         };

  subtype 'USZipCode'
      =&gt; as Value
      =&gt; where {
             /^$RE{zip}{US}{-extended =&gt; 'allow'}$/;
         };

  has 'street'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );
  has 'city'     =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );
  has 'state'    =&gt; ( is =&gt; 'rw', isa =&gt; 'USState' );
  has 'zip_code' =&gt; ( is =&gt; 'rw', isa =&gt; 'USZipCode' );

  package Company;
  use Moose;
  use Moose::Util::TypeConstraints;

  has 'name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'address'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );
  has 'employees' =&gt; ( is =&gt; 'rw', isa =&gt; 'ArrayRef[Employee]' );

  sub BUILD {
      my ( $self, $params ) = @_;
      if ( @{ $self-&gt;employees || [] } ) {
          foreach my $employee ( @{ $self-&gt;employees } ) {
              $employee-&gt;employer($self);
          }
      }
  }

  after 'employees' =&gt; sub {
      my ( $self, $employees ) = @_;
      if ($employees) {
          foreach my $employee ( @{$employees} ) {
              $employee-&gt;employer($self);
          }
      }
  };

  package Person;
  use Moose;

  has 'first_name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'last_name'  =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'middle_initial' =&gt; (
      is        =&gt; 'rw', isa =&gt; 'Str',
      predicate =&gt; 'has_middle_initial'
  );
  has 'address' =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );

  sub full_name {
      my $self = shift;
      return $self-&gt;first_name
          . (
          $self-&gt;has_middle_initial
          ? ' ' . $self-&gt;middle_initial . '. '
          : ' '
          ) . $self-&gt;last_name;
  }

  package Employee;
  use Moose;

  extends 'Person';

  has 'title'    =&gt; ( is =&gt; 'rw', isa =&gt; 'Str',     required =&gt; 1 );
  has 'employer' =&gt; ( is =&gt; 'rw', isa =&gt; 'Company', weak_ref =&gt; 1 );

  override 'full_name' =&gt; sub {
      my $self = shift;
      super() . ', ' . $self-&gt;title;
  };

</pre>

</div>
<h2 id="-3">本文</h2>
<div id="CONTENT-3">
<p>このレシピでは<cite>Moose::Util::TypeConstraints</cite>が提供している<code>subtype</code>というシュガー関数について紹介します。<code>subtype</code>関数を使うとクラスをひとつまるごと用意しなくても宣言的に型制約を生成できるようになります。</p>
<p>また、既存のCPANツールを使ってデータを検証する方法を紹介するため、<cite>Locale::US</cite>と<cite>Regexp::Common</cite>を使った制約も作成します。</p>
<p>最後に、<code>required</code>というアトリビュートオプションを紹介します。</p>
<p><code>Address</code>クラスでは2つのサブタイプを定義しています。ひとつめのサブタイプは、<cite>Locale::US</cite>モジュールを使って州の名前を検証するものです。このサブタイプは、州の略称も正式名称も受け付けるようになっています。</p>
<p>州の名前は文字列として渡したいので、<code>USState</code>型はMoose組み込みの<code>Str</code>型のサブタイプにしました。これは<code>as</code>というシュガー関数を使って指定します。実際の制約は<code>where</code>を使って定義します（この関数はサブルーチンリファレンスをひとつ受け取ります）。このサブルーチンを呼ぶと、チェックしたい値が<code>$_</code>に入ります(1)。また、返り値としてはその型として有効な値かどうかをあらわす真偽値が期待されています。</p>
<p>これで<code>USState</code>型はMooseの組み込み型と同じように使えるようになりました。</p>
<pre>  has 'state'    =&gt; ( is =&gt; 'rw', isa =&gt; 'USState' );

</pre>
<p><code>state</code>アトリビュートに値がセットされると、<code>USState</code>型の制約を満たすかチェックされ、値が有効でなかった場合は例外が発生します。</p>
<p>次の<code>USZipCode</code>というサブタイプでは<cite>Regexp::Common</cite>を使います。<cite>Regexp::Common</cite>にはアメリカの郵便番号を検証する正規表現が含まれていますので、これを<code>zip_code</code>アトリビュートの制約として利用します。</p>
<pre>  subtype 'USZipCode'
      =&gt; as Value
      =&gt; where {
             /^$RE{zip}{US}{-extended =&gt; 'allow'}$/;
         };

</pre>
<p>それぞれの型についてクラスを要求するかわりにサブタイプを使うと、コードが非常に簡潔になります。ここで取り上げた型の場合、値は単なる文字列ですから本当にクラスは必要ありません（ただし、有効な値かどうか確認したいのは本当です）。</p>
<p>ここで作成した型制約は再利用できます。型制約はグローバルなレジストリに名前付きで保存されるので、ほかのクラスからも参照できるのです。ただし、このレジストリはグローバルなので、実際のアプリケーションでは<code>MyApp.Type.USState</code>のようになんらかの擬似的な名前空間を利用することを強くおすすめします。</p>
<p>この2つのサブタイプを使うと、簡単な<code>Address</code>クラスを定義できます。</p>
<p>続いて、<code>Company</code>クラスを定義しましょう。このクラスには住所の情報を持たせます。これまでのレシピで見たように、Mooseはそれぞれのクラスに自動的に型制約を生成してくれるので、ここでも<code>Company</code>クラスの<code>address</code>アトリビュートにはその自動生成された型制約を利用します。</p>
<pre>  has 'address'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );

</pre>
<p>また、会社には名前も必要です。</p>
<pre>  has 'name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );

</pre>
<p>ここでは<code>required</code>という新しいアトリビュートオプションが登場しました。アトリビュートが必須になっている場合、かならずクラスのコンストラクタにそのアトリビュートを渡さなければなりません（そうでない場合は例外が発生します）。ただし、これもぜひ理解しておいていただきたいのですが、<code>required</code>アトリビュートは、型制約が許せば偽値や<code>undef</code>であってもかまいません。</p>
<p>次の<code>employees</code>アトリビュートでは「パラメータ付きの」型制約を利用しています。</p>
<pre>  has 'employees' =&gt; ( is =&gt; 'rw', isa =&gt; 'ArrayRef[Employee]' );

</pre>
<p>この制約の意味は、<code>employees</code>は配列リファレンスでなければならず、配列のそれぞれの要素は<code>Employee</code>オブジェクトでなければならない、ということ（「空の」配列リファレンスもこの制約を満たすことは注記しておくべきでしょう）。</p>
<p><code>ArrayRef[`a]</code>のようなパラメータ指定可能な型制約（「コンテナ」型）は、型パラメータを使うとより具体的に書けますが（実際にはこれらの型を任意の回数ネストさせて<code>HashRef[ArrayRef[Int]]</code>のような制約を作ることもできます）、指定された型を単独で使うだけでもかまいません（だから、<code>ArrayRef</code>という型制約も合法です）。(2)</p>
<p>途中を飛ばして<code>Employee</code>クラスの定義を見ると、<code>employer</code>アトリビュートがあります。</p>
<p><code>Company</code>の<code>employees</code>に値をセットしたときは、それぞれの従業員オブジェクトの<code>employer</code>アトリビュートも確実に正しい<code>Company</code>を参照させたいところです。</p>
<p>そのためにはオブジェクトの生成に割り込みをかける必要があります。Mooseでは、クラスに<code>BUILD</code>メソッドを書くとそうすることができるようになります。定義しておいた<code>BUILD</code>メソッドは、オブジェクトが生成された直後、呼び出し元にそのオブジェクトを返す前に呼ばれます。(3)</p>
<p><code>Company</code>クラスでは<code>BUILD</code>メソッドを使って会社の各従業員がかならず<code>employer</code>アトリビュートに適切な<code>Company</code>オブジェクトを持つようにしています。</p>
<pre>  sub BUILD {
      my ( $self, $params ) = @_;
      if ( $self-&gt;employees ) {
          foreach my $employee ( @{ $self-&gt;employees } ) {
              $employee-&gt;employer($self);
          }
      }
  }

</pre>
<p>この<code>BUILD</code>メソッドは、型制約のチェックが済んだあとに実行されます。だから、<code>$self-&gt;employees</code>が配列リファレンスを返すことや、その配列の要素が<code>Employee</code>オブジェクトであることは間違いないものと決めてかかっても大丈夫です。</p>
<p>また、<code>Company</code>の<code>employees</code>アトリビュートが変わったときもかならず各従業員の<code>employer</code>を更新しておきたいところです。</p>
<p>そうするには、<code>after</code>モディファイアが使えます。</p>
<pre>  after 'employees' =&gt; sub {
      my ( $self, $employees ) = @_;
      if ($employees) {
          foreach my $employee ( @{$employees} ) {
              $employee-&gt;employer($self);
          }
      }
  };

</pre>
<p>ここでもまた、<code>BUILD</code>メソッドと同じく事前に型制約のチェックが済んでいることはわかっていますので、<code>$employees</code>引数が定義されているかどうかだけのチェックで済ませられます。</p>
<p><strong>Person</strong>クラスには特に目新しいことはありません。<code>required</code>なアトリビュートがいくつかあるのと、<b>レシピ3</b> (<cite>Moose::Cookbook::Basics::Recipe3</cite>)ではじめて使った<code>predicate</code>メソッドがひとつあります。</p>
<p><code>Employee</code>クラスも、新しい機能は<code>override</code>メソッドモディファイアだけです。</p>
<pre>  override 'full_name' =&gt; sub {
      my $self = shift;
      super() . ', ' . $self-&gt;title;
  };

</pre>
<p>これはPerlに組み込まれている<code>SUPER::</code>機能のかわりをするシュガー関数に過ぎないのですが、ひとつ違うところがあります。<code>super</code>には引数を渡せないのです（Mooseは単にメソッドに渡されたのと同じパラメータを渡します）。</p>
<p><cite>t/000_recipes/moose_cookbook_basics_recipe4.t</cite>にはもっと詳しい使用例があります。</p>

</div>
<h2 id="-4">まとめ</h2>
<div id="CONTENT-4">
<p>このレシピはあえてやや長く、複雑なものにしました。ここではMooseのクラスと型制約を組み合わせて使う方法や、Mooseを使うとわずかなタイプ量でさまざまな情報を取得できるようになることを説明しました。</p>
<p>また、このレシピでは<code>subtype</code>関数や<code>required</code>アトリビュート、<code>override</code>メソッドモディファイアの使い方も紹介しました。</p>
<p>型制約については型変換ともどもこの先のレシピで再度取り上げます。</p>

</div>
<h2 id="-5">脚注</h2>
<div id="CONTENT-5">
<dl>
	<dt>(1)</dt>
	<dd>
		<p>チェックしたい値は<code>where</code>ブロックの最初の引数として渡されます（<code>$_[0]</code>でアクセスできます）。</p>
	</dd>
	<dt>(2)</dt>
	<dd>
		<p>ただし、<code>ArrayRef[]</code>は正しく動作しません。このような場合、Mooseはコンテナ型とはみなさず、「ArrayRef[]」という意味不明な新しい型が指定されたものとみなすためです。</p>
	</dd>
	<dt>(3)</dt>
	<dd>
		<p><code>BUILD</code>メソッドは、実際には<code>Moose::Object-&gt;new</code>が呼び出す<code>Moose::Object-&gt;BUILDALL</code>から呼ばれます。<code>BUILDALL</code>メソッドは、オブジェクトの継承グラフをたどって、見つけた<code>BUILD</code>メソッドをすべて、正しい順序で呼び出すものです。</p>
	</dd>
</dl>

</div>
<h2 id="-6">作者</h2>
<div id="CONTENT-6">
<p>Stevan Little &lt;stevan@iinteractive.com&gt;</p>
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2006-2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>


<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>

	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

