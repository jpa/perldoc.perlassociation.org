<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<title>Moose::Cookbook::Basics::Recipe1 Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css">
</head>
<body>

	
<h1>Moose::Cookbook::Basics::Recipe1</h1>
<div class="path" id="path"><a href="/">HOME</a> &gt; <a href="/Moose/Cookbook/Basics/Recipe1.html">Moose::Cookbook::Basics::Recipe1</a></div><div class="pod">
<!-- INDEX START -->

<ul class="list-index"><li><a href="#">題名</a></li>
<li><a href="#-2">概要</a></li>
<li><a href="#-3">本文</a>
<ul>
<li>
<ul><li><a href="#Moose">Mooseオブジェクトはハッシュリファレンスにすぎません</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#-4">まとめ</a></li>
<li><a href="#-5">脚注</a></li>
<li><a href="#-6">参照</a></li>
<li><a href="#-7">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Cookbook::Basics::Recipe1 - (毎度おなじみ) <strong>Point</strong>の例</p>

</div>
<h2 id="-2">概要</h2>
<div id="CONTENT-2">
<pre>  package Point;
  use Moose;

  has 'x' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);
  has 'y' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);

  sub clear {
      my $self = shift;
      $self-&gt;x(0);
      $self-&gt;y(0);
  }

  package Point3D;
  use Moose;

  extends 'Point';

  has 'z' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);

  after 'clear' =&gt; sub {
      my $self = shift;
      $self-&gt;z(0);
  };

  package main;

  # hash or hashrefs are ok for the constructor
  my $point1 = Point-&gt;new(x =&gt; 5, y =&gt; 7);
  my $point2 = Point-&gt;new({x =&gt; 5, y =&gt; 7});

  my $point3d = Point3D-&gt;new(x =&gt; 5, y =&gt; 42, z =&gt; -5);

</pre>

</div>
<h2 id="-3">本文</h2>
<div id="CONTENT-3">
<p>これは古典的なPointの例です。Perl 6の黙示録12番からそのまま引用してきました。K&amp;Rの古典的なCの教科書にも同じような例が載っています。</p>
<p>Perl 5のクラスはすべてそうですが、Mooseのクラスもパッケージの中で定義されます。<code>strict</code>と<code>warnings</code>はMooseの方で有効にしてくれますので、<code>use Moose</code>とさえ書いておけばうっかりミスを防げます。</p>
<p>Mooseはロードされると呼び出し元のパッケージ内にシュガー関数をいくつかエクスポートします（つまり、私たちはMooseの「キーワード」になる関数をいくつかインポートします）。もっとも、これらの関数は本当にPerl 5のキーワードになるわけではありません。あくまでも私たちのパッケージにエクスポートされたPerlの関数にすぎないものです。</p>
<p>Mooseは自動的に私たちのパッケージを<cite>Moose::Object</cite>のサブクラスにします。<cite>Moose::Object</cite>クラスは、アトリビュートに対応したコンストラクタなど、さまざまな機能を提供してくれるものです。詳しくは<cite>Moose::Object</cite>をご覧ください。</p>
<p>続いてはキーワードについてです。ここで紹介する最初のキーワードは<code>has</code>です。これはクラスの中でインスタンスのアトリビュートを定義するものです。</p>
<pre>  has 'x' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);

</pre>
<p>このようにすると、<code>x</code>という名前のアトリビュートが生成されます。<code>isa</code>パラメータは、このアトリビュートに保存される値は<code>Int</code>型の制約を満たすことを期待している、という意味です(1)。このアトリビュート用に生成されるアクセサは読み書き可能になります。</p>
<p><code>requires =&gt; 1</code>というパラメータは、新しいオブジェクトを生成するときにはかならずこのアトリビュートを用意しなければならないという意味です（座標情報のないpointオブジェクトはあまり意味があるとは思えないので許していません）。</p>
<p>アトリビュートを定義したので、今度はメソッドを定義しましょう。Mooseの場合も、ふつうのPerl 5のオブジェクト指向と同じく、メソッドはパッケージ内で定義されたサブルーチンにすぎません。</p>
<pre>  sub clear {
      my $self = shift;
      $self-&gt;x(0);
      $self-&gt;y(0);
  }

</pre>
<p>これで<strong>Point</strong>クラスはおしまいです。</p>
<p>続いて、<strong>Point</strong>のサブクラスである<strong>Point3D</strong>を作りましょう。スーパークラスを宣言するにはMooseのキーワードである<code>extends</code>を使います。</p>
<pre>  extends 'Point';

</pre>
<p>この<code>extends</code>キーワードは<code>use base</code>によく似て、最初に必要があればクラスをロードするのですが、<code>base</code>と違って、<code>extends</code>キーワードはパッケージの<code>@ISA</code>にどんな値が含まれていても「上書き」してしまいます（<code>use base</code>はパッケージの<code>@ISA</code>に値を追加します）。</p>
<p>個人的には、<code>extends</code>の振る舞いの方が直感的だと思います。(2)</p>
<p>次に、<strong>Point3D</strong>に<code>z</code>という新しいアトリビュートを作ります。</p>
<pre>  has 'z' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);

</pre>
<p>このアトリビュートは<strong>Point</strong>の<code>x</code>、<code>y</code>アトリビュートと同じようなものです。</p>
<p><code>after</code>キーワードは、Mooseでは「メソッドモディファイア」（アスペクト指向プログラミングでいう「アドバイス」）と呼ばれる機能です。</p>
<pre>  after 'clear' =&gt; sub {
      my $self = shift;
      $self-&gt;z(0);
  };

</pre>
<p><strong>Point3D</strong>オブジェクトで<code>clear</code>が呼ばれると、モディファイアメソッドも呼ばれます（当然ながら、モディファイアが呼ばれるのは本物のメソッドの「あと」になります）。</p>
<p>この例では、本物の<code>clear</code>メソッドは<strong>Point</strong>から継承したものです。モディファイアメソッドは修飾されるメソッドと同じ引数を受け取ります（この場合は<code>$self</code>のみです）。</p>
<p>もちろん<code>after</code>モディファイアを使うのが唯一のやり方ではありません。<strong>これはPerlですから</strong>ね。このようなコードでも同じ結果が得られます。</p>
<pre>  sub clear {
      my $self = shift;
      $self-&gt;SUPER::clear();
      $self-&gt;z(0);
  }

</pre>
<p>また、<code>override</code>という別のモディファイアを使うこともできるでしょう。</p>
<pre>  override 'clear' =&gt; sub {
      my $self = shift;
      super();
      $self-&gt;z(0);
  };

</pre>
<p><code>override</code>モディファイアを使うと<code>super</code>というキーワードを利用できるようになります。これは非常にRuby的なやり方でスーパークラスのメソッドにディスパッチするためのものです。</p>
<p>メソッドモディファイアを使うかどうか、またどのモディファイアを使うかどうかの選択は、往々にして機能の問題であるのと同じくらいスタイルの問題でもあります。</p>
<p><strong>Point</strong>は<cite>Moose::Object</cite>を継承しているので、<cite>Moose::Object</cite>のデフォルトコンストラクタも継承します。</p>
<pre>  my $point1 = Point-&gt;new(x =&gt; 5, y =&gt; 7);
  my $point2 = Point-&gt;new({x =&gt; 5, y =&gt; 7});

  my $point3d = Point3D-&gt;new(x =&gt; 5, y =&gt; 42, z =&gt; -5);

</pre>
<p><code>new</code>コンストラクタはこのクラスで定義されている各アトリビュートの名前付き引数のペアを、ハッシュまたはハッシュリファレンスの形で受け付けます。この例の場合、アトリビュートは必須ですから、引数を渡さずに<code>new</code>を呼ぶとエラーになります。</p>
<pre>  my $point = Point-&gt;new( x =&gt; 5 ); # no y, kaboom!

</pre>
<p>これで、<code>$point</code>と<code>$point3d</code>はほかのPerl 5オブジェクトと同様に使えるようになりました。どんなことができるかをもっと詳しく知りたい方は<cite>t/000_recipes/moose_cookbook_basics_recipe1.t</cite>のテストファイルをご覧ください。</p>

</div>
<h3 id="Moose">Mooseオブジェクトはハッシュリファレンスにすぎません</h3>
<div id="Moose_CONTENT">
<p>ここまで紹介してきたことはいずれもいささか魔法じみて見えるかもしれませんが、大事なのは、Mooseのオブジェクトはフードをかぶったハッシュリファレンスにすぎない、ということ(3)。たとえば、<code>$self</code>を<code>Data::Dumper</code>に渡してやれば、まさに期待通りの出力が得られます。</p>
<p>オブジェクトのデータ構造の中をつつき回すことさえできます（まったくおすすめできませんが）。</p>
<p>Mooseのオブジェクトがハッシュリファレンスであるということは、Mooseを使っていないクラスであってもハッシュリファレンスでさえあれば簡単にMooseで拡張できるということ。ハッシュリファレンス以外のクラスを拡張したい場合は、<code>MooseX::InsideOut</code>を試してみてください。</p>

</div>
<h2 id="-4">まとめ</h2>
<div id="CONTENT-4">
<p>このレシピではいくつかの基本的なコンセプト（アトリビュート、サブクラス、簡単なメソッドモディファイア）について説明しました。</p>

</div>
<h2 id="-5">脚注</h2>
<div id="CONTENT-5">
<dl>
	<dt>(1)</dt>
	<dd>
		<p>Mooseには最初から多くの型制約が用意されています（<code>Int</code>もそのひとつです）。型制約システムについての詳細は<cite>Moose::Util::TypeConstraints</cite>をご覧ください。</p>
	</dd>
	<dt>(2)</dt>
	<dd>
		<p><code>extends</code>キーワードは多重継承をサポートしています（単にすべてのスーパークラスを配列の形で<code>extends</code>に渡すだけです）。</p>
<pre>  extends 'Foo', 'Bar', 'Baz';

</pre>
	</dd>
	<dt>(3)</dt>
	<dd>
		<p>Mooseはblessされたハッシュリファレンス以外のインスタンスもサポートしています（グロブリファレンスなど。<cite>MooseX::GlobRef::Object</cite>をご覧ください）。</p>
	</dd>
</dl>

</div>
<h2 id="-6">参照</h2>
<div id="CONTENT-6">
<dl>
	<dt>メソッドモディファイア</dt>
	<dd>
		<p>メソッドモディファイアの概念はCLOSのものをそのまま借用しました。下記のリンク先にはすばらしい説明があります。</p>
		<p><a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html</a></p>
	</dd>
</dl>

</div>
<h2 id="-7">作者</h2>
<div id="CONTENT-7">
<p>Stevan Little &lt;stevan@iinteractive.com&gt;</p>
<p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2006-2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	<li><img src="http://lazy-css.org/css/img/g_news.png" alt="ニュース"></li>
	<li><img src="http://lazy-css.org/css/img/g_blog.png" alt="ブログ"></li>
	</ul>
</div>


<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>

	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>
</div>
</body>
</html>

