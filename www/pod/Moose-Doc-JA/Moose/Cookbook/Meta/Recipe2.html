<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<title>Moose::Cookbook::Meta::Recipe2 Moose(0.79) - Japan Perl Association ドキュメント和訳プロジェクト</title>
<link rel="stylesheet" type="text/css" href="http://lazy-css.org/css/style.css">
</head>
<body>
<h1>Moose::Cookbook::Meta::Recipe2</h1>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>

<ul><li><a href="#">題名</a></li>
<li><a href="#-2">概要</a></li>
<li><a href="#-3">要約</a></li>
<li><a href="#-4">メタアトリビュートオブジェクト</a></li>
<li><a href="#-5">レシピのおさらい</a></li>
<li><a href="#-6">まとめ</a></li>
<li><a href="#-7">作者</a></li>
<li><a href="#COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</a>
</li>
</ul><hr />
<!-- INDEX END -->

<h2 id="">題名</h2>
<div id="CONTENT">
<p>Moose::Cookbook::Meta::Recipe2 - メタアトリビュート、ラベル付きのアトリビュート</p>

</div>
<h2 id="-2">概要</h2>
<div id="CONTENT-2">
<pre>  package MyApp::Meta::Attribute::Labeled;
  use Moose;
  extends 'Moose::Meta::Attribute';

  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );

  package Moose::Meta::Attribute::Custom::Labeled;
  sub register_implementation {'MyApp::Meta::Attribute::Labeled'}

  package MyApp::Website;
  use Moose;

  has url =&gt; (
      metaclass =&gt; 'Labeled',
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      label     =&gt; &quot;The site's URL&quot;,
  );

  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );

  sub dump {
      my $self = shift;

      my $dump = '';

      my %attributes = %{ $self-&gt;meta-&gt;get_attribute_map };
      for my $name ( sort keys %attributes ) {
          my $attribute = $attributes{$name};

          if (   $attribute-&gt;isa('MyApp::Meta::Attribute::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }
          else {
              $dump .= $name;
          }

          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }

      return $dump;
  }

  package main;

  my $app = MyApp::Website-&gt;new( url =&gt; &quot;http://google.com&quot;, name =&gt; &quot;Google&quot; );

</pre>

</div>
<h2 id="-3">要約</h2>
<div id="CONTENT-3">
<p>このレシピからは、不思議なメタプログラミングの世界に深入りしていきます。読者の中には「そんなのはいかれまくった変態開発者だけの世界だ」と冷笑する方もいるかもしれませんが、断じてそんなことはありません！　それなりにいかれた開発者であれば、メタを利用すれば多大な恩恵を受けられます。</p>
<p>ここでの目標は、それぞれのアトリビュートに人が読んでわかるような「ラベル」を追加することです。このようなラベルがあれば、エンドユーザにデータを見せるときに利用できます。このレシピでは、<code>url</code>アトリビュートに「このサイトのURL」というラベルをつけ、そのラベルの使い方を紹介する簡単なメソッドを作ります。</p>

</div>
<h2 id="-4">メタアトリビュートオブジェクト</h2>
<div id="CONTENT-4">
<p>Mooseベースのオブジェクトのアトリビュートは、実際にはすべてオブジェクトであり、メソッドやアトリビュートを持っています。具体的な例を見てみましょう。</p>
<pre>  has 'x' =&gt; ( isa =&gt; 'Int', is =&gt; 'ro' );
  has 'y' =&gt; ( isa =&gt; 'Int', is =&gt; 'rw' );

</pre>
<p>内部的には、<code>Point</code>のメタクラスは<cite>Moose::Meta::Attribute</cite>を2つ持っています。メタクラスからメタアトリビュートを取り出す方法はいくつかありますが、そのひとつに<code>get_attribute_map</code>というメソッドがあります。このメソッドはメタクラスオブジェクトから呼べます。</p>
<p><code>get_attribute_map</code>メソッドはアトリビュート名とオブジェクトがマッピングされたハッシュリファレンスを返します。今回の場合、<code>get_attribute_map</code>はこのようなハッシュリファレンスを返すはずです。</p>
<pre>  {
      x =&gt; $attr_object_for_x,
      y =&gt; $attr_object_for_y,
  }

</pre>
<p>また、<code>get_attribute('name')</code>を使うと単独の<cite>Moose::Meta::Attribute</cite>を取り出すこともできます。メタアトリビュートオブジェクトを取り出したら、このようなメソッドを呼ぶことができます。</p>
<pre>  print $point-&gt;meta-&gt;get_attribute('x')-&gt;type_constraint;
     =&gt; Int

</pre>
<p>アトリビュートにラベルを追加するには、2つの手順を踏む必要があります。まず、アトリビュートのラベルを保存できる新しいアトリビュートメタクラスが必要です。また、そのアトリビュートメタクラスを利用するアトリビュートを作成する必要があります。</p>

</div>
<h2 id="-5">レシピのおさらい</h2>
<div id="CONTENT-5">
<p>まずは新しいアトリビュートメタクラスから作っていきます。</p>
<pre>  package MyApp::Meta::Attribute::Labeled;
  use Moose;
  extends 'Moose::Meta::Attribute';

</pre>
<p>Mooseのメタクラスもほかのものをサブクラス化するのと同じやり方でサブクラス化できます。</p>
<pre>  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );

</pre>
<p>これもまた標準的なMooseのコードです。</p>
<p>続いて、Mooseを使って私たちのメタクラスを登録する必要があります。</p>
<pre>  package Moose::Meta::Attribute::Custom::Labeled;
  sub register_implementation { 'MyApp::Meta::Attribute::Labeled' }

</pre>
<p>ここではちょっとした魔法を使って、新しいメタクラスを参照するときに「Labeled」という短い名前を使えるようにしています。</p>
<p>これでアトリビュートメタクラスはおしまいです。</p>
<p>今度はアトリビュートメタクラスを使ってみましょう。</p>
<pre>  package MyApp::Website;
  use Moose;
  use MyApp::Meta::Attribute::Labeled;

</pre>
<p>ほかのPerlのクラスと同様に、メタクラスを使うにはロードする必要があります。</p>
<p>いよいよアトリビュートにメタクラスを適用します。</p>
<pre>  has url =&gt; (
      metaclass =&gt; 'Labeled',
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      label     =&gt; &quot;The site's URL&quot;,
  );

</pre>
<p>これは一見ふつうのアトリビュート宣言ですが、2つ異なっているところがあります。<code>metaclass</code>パラメータと<code>label</code>パラメータです。<code>metaclass</code>パラメータはMooseにこのアトリビュートでは独自のメタクラスを利用したい、ということを伝えるものです。<code>label</code>パラメータはメタアトリビュートオブジェクトに保存されます。</p>
<p><code>MyApp::Meta::Attribute::Labeled</code>ではなく<code>Labeled</code>という名前を渡せるのは、先ほど触れた<code>register_implementation</code>というコードのおかげです。</p>
<p><code>has</code>にメタクラスを渡すと、Mooseは受け取ったメタクラス名に<code>Moose::Meta::Attribute::Custom::</code>というプレフィックスをつけて、そのパッケージ内の<code>register_implementation</code>を呼びます（この場合は最終的に<code>Moose::Meta::Attribute::Custom::Labeled::register_implementation</code>を呼ぶことになります）。</p>
<p>この関数が存在している場合は「本当の」メタクラスパッケージ名を返すことになっています（ここで<code>MyApp::Meta::Attribute::Labeled</code>を返しているのはまさにそれです）。ただ、このやり方はいささか複雑なので、気に入らない場合は、いつでも完全修飾名を使ってください。</p>
<p>このメタアトリビュートとラベルにはこのような形でアクセスできます。</p>
<pre>  $website-&gt;meta-&gt;get_attribute('url')-&gt;label()

  MyApp::Website-&gt;meta-&gt;get_attribute('url')-&gt;label()

</pre>
<p>また、ここでは<code>name</code>というふつうのアトリビュートも用意してあります。</p>
<pre>  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );

</pre>
<p>これは新しいメタクラスを指定していませんから、いつも通りのMooseのアトリビュートです。</p>
<p>いよいよ<code>dump</code>メソッドです。これは<code>MyApp::Website</code>オブジェクトを人が読める形にするものです。ここではアトリビュートのラベルがあればそれを利用するようになっています。</p>
<pre>  sub dump {
      my $self = shift;

      my $dump = '';

      my %attributes = %{ $self-&gt;meta-&gt;get_attribute_map };
      for my $name ( sort keys %attributes ) {
          my $attribute = $attributes{$name};

          if (   $attribute-&gt;isa('MyApp::Meta::Attribute::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }

</pre>
<p>これはやや防衛的なコードになっています。すべてのメタアトリビュートがラベルを持っているとは限りません。私たちが自分のクラスのすべてのアトリビュートにラベルを定義したとしても、サブクラスはそうしないかもしれませんし、スーパークラスがラベルのないアトリビュートを追加するかもしれないからです。</p>
<p>また、ここで定義した断定用のメソッドを使って、アトリビュートがラベルを持っているかどうかもチェックしています。あるいはラベルを<code>required</code>にしてもよいかもしれません。ラベルがあればそれを利用し、なければアトリビュート名を利用します。</p>
<pre>          else {
              $dump .= $name;
          }

          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }

      return $dump;
  }

</pre>
<p><code>get_read_method</code>は<cite>Moose::Meta::Attribute</cite>のAPIからきています。これは「本当のオブジェクトに対して呼ばれた場合は」アトリビュートの値を読み込むときに使えるメソッド名を返します（メタアトリビュートに対しては使わないでください）。</p>

</div>
<h2 id="-6">まとめ</h2>
<div id="CONTENT-6">
<p>どうしてこんな手間をかけるのかと思われたかもしれません。<code>dump</code>メソッドに「このサイトのURL」とハードコードするだけでもいいように思えます。でも、繰り返しは避けたいものです。どこかでラベルが必要になったということは、別の箇所、たとえば次に書く<code>as_form</code>というメソッドでもラベルが必要になるかもしれないということ。</p>
<p>ラベルをアトリビュートに紐づけておけば筋が通ります！　ラベルはそのアトリビュート「についての」情報なのですから。</p>
<p>もうひとつぜひ理解しておいていただきたいのは、今回の例はつまらないものだったということ。単に追加情報を保存しておくだけでなく、もっといろいろなことをしてくれる、はるかに強力なメタクラスを作ることもできるのです。たとえば、一定時間がたったらアトリビュートを期限切れにするメタクラスを実装してみてもよいでしょう。</p>
<pre>   has site_cache =&gt; (
       metaclass     =&gt; 'TimedExpiry',
       expires_after =&gt; { hours =&gt; 1 },
       refresh_with  =&gt; sub { get( $_[0]-&gt;url ) },
       isa           =&gt; 'Str',
       is            =&gt; 'ro',
   );

</pre>
<p>可能性は無限大です！</p>

</div>
<h2 id="-7">作者</h2>
<div id="CONTENT-7">
<p>Shawn M Moore &lt;sartak@gmail.com&gt;</p>
<p>Dave Rolsky &lt;autarch@urth.org&lt;gt&gt;</p>

</div>
<h2 id="COPYRIGHT_AND_LICENSE">COPYRIGHT AND LICENSE</h2>
<div id="COPYRIGHT_AND_LICENSE_CONTENT">
<p>Copyright 2006-2009 by Infinity Interactive, Inc.</p>
<p><a href="http://www.iinteractive.com">http://www.iinteractive.com</a></p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

</div>
</div>
<div class="head">
	<div class="logo">
	<img src="http://lazy-css.org/css/img/logo.png">
	</div>
	<ul class="global-navi">

	<li><img src="http://lazy-css.org/css/img/g_home.png" alt="ホーム"></li>
	</ul>
</div>

<div class="footer">
<ul class="footer-navi">
	<li>リンク</li>
	<li>リンク</li>
	<li>リンク</li>

	<li>リンク</li>
</ul>
<address>&copy; copyright 2009 jpa all right reserved.</address>

</body>
</html>

